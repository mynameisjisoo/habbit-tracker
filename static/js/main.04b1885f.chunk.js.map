{"version":3,"sources":["components/habit.jsx","components/habitAddForm.jsx","components/habits.jsx","components/header.jsx","app.jsx","components/simpleHabit.jsx","index.js"],"names":["Habit","handleIncrement","props","onIncrement","habit","handleDecrement","onDecrement","handleDelete","onDelete","console","log","this","name","count","className","onClick","PureComponent","HabitAddForm","memo","inputRef","React","createRef","formRef","ref","onSubmit","event","preventDefault","current","value","onAdd","reset","type","placeholder","Habits","handleAdd","habits","map","id","onReset","Component","Header","totalCount","SimpleHabit","useState","setCount","spanRef","useRef","useCallback","useEffect","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"6PA4DeA,E,4MA7CbC,gBAAkB,WAChB,EAAKC,MAAMC,YAAY,EAAKD,MAAME,Q,EAEpCC,gBAAkB,WAChB,EAAKH,MAAMI,YAAY,EAAKJ,MAAME,Q,EAEpCG,aAAe,WACb,EAAKL,MAAMM,SAAS,EAAKN,MAAME,Q,uDAlBjC,WAEEK,QAAQC,IAAR,iBAAsBC,KAAKT,MAAME,MAAMQ,KAAvC,e,kCAGF,WAEEH,QAAQC,IAAR,iBAAsBC,KAAKT,MAAME,MAAMQ,KAAvC,mB,oBAcF,WAAU,IAAD,EACiBD,KAAKT,MAAME,MAA3BQ,EADD,EACCA,KAAMC,EADP,EACOA,MAId,OAFAJ,QAAQC,IAAR,iBAAsBE,IAGpB,qBAAIE,UAAU,QAAd,UACE,sBAAMA,UAAU,aAAhB,SAA8BF,IAC9B,sBAAME,UAAU,cAAhB,SAA+BD,IAC/B,wBACEC,UAAU,8BACVC,QAASJ,KAAKV,gBAFhB,SAOE,mBAAGa,UAAU,yBAEf,wBACEA,UAAU,8BACVC,QAASJ,KAAKN,gBAFhB,SAIE,mBAAGS,UAAU,0BAEf,wBACEA,UAAU,4BACVC,QAASJ,KAAKJ,aAFhB,SAIE,mBAAGO,UAAU,0B,GAnDHE,iBC0BLC,EAzBMC,gBAAK,SAAAhB,GACxBO,QAAQC,IAAI,kBACZ,IAAMS,EAAWC,IAAMC,YACjBC,EAAUF,IAAMC,YAStB,OACE,uBAAME,IAAKD,EAASR,UAAU,WAAWU,SAR1B,SAAAC,GACfA,EAAMC,iBACN,IAAMd,EAAOO,EAASQ,QAAQC,MAC9BhB,GAAQV,EAAM2B,MAAMjB,GAEpBU,EAAQK,QAAQG,SAGhB,UACE,uBACEP,IAAKJ,EACLY,KAAK,OACLjB,UAAU,YACVkB,YAAY,4BAEd,wBAAQlB,UAAU,UAAlB,uBCUSmB,E,4MA5BbC,UAAY,SAAAtB,GACV,EAAKV,MAAM2B,MAAMjB,I,4CAGnB,WAAU,IAAD,OAEP,OADAH,QAAQC,IAAI,UAEV,gCACE,cAAC,EAAD,CAAcmB,MAAOlB,KAAKuB,YAC1B,oBAAIpB,UAAU,SAAd,SACGH,KAAKT,MAAMiC,OAAOC,KAAI,SAAAhC,GAAK,OAC1B,cAAC,EAAD,CAEEA,MAAOA,EACPD,YAAa,EAAKD,MAAMC,YACxBG,YAAa,EAAKJ,MAAMI,YACxBE,SAAU,EAAKN,MAAMM,UAJhBJ,EAAMiC,SAQjB,wBAAQvB,UAAU,eAAeC,QAASJ,KAAKT,MAAMoC,QAArD,0B,GArBaC,aCYNC,E,4JAbb,WAGE,OAFA/B,QAAQC,IAAI,UAGV,yBAAQI,UAAU,SAAlB,UACE,mBAAGA,UAAU,kCACb,kDACA,sBAAMA,UAAU,eAAhB,SAAgCH,KAAKT,MAAMuC,oB,GAR9BzB,iB,GCGHuB,Y,aC2BHG,EA9BK,WAAM,MAEEC,mBAAS,GAFX,mBAEjB9B,EAFiB,KAEV+B,EAFU,KAGlBC,EAAUzB,IAAM0B,SAEhB7C,EAAkB8C,uBAAY,WAClCH,EAAS/B,EAAQ,MAWnB,OAHAmC,qBAAU,WACRvC,QAAQC,IAAR,+BAAoCG,MACnC,CAACA,IAEF,qBAAIC,UAAU,QAAd,UACE,sBAAMS,IAAKsB,EAAS/B,UAAU,aAA9B,qBAGA,sBAAMA,UAAU,cAAhB,SAA+BD,IAC/B,wBAAQC,UAAU,8BAA8BC,QAASd,EAAzD,SACE,mBAAGa,UAAU,6BCnBrBmC,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,W","file":"static/js/main.04b1885f.chunk.js","sourcesContent":["import React, { PureComponent } from 'react';\r\n\r\nclass Habit extends PureComponent {\r\n  //Lifecycle method 상황에 맞게 구현하면 됨\r\n  componentDidMount() {\r\n    //컴포넌트가 UI상에 등록될 때 호출(사용자에게 보여질 때)\r\n    console.log(`habit: ${this.props.habit.name} mounted`);\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    //컴포넌트가 없어질 때\r\n    console.log(`habit: ${this.props.habit.name}will unmount`);\r\n  }\r\n\r\n  // Habit는 자체적으로 갖고있는 state는 없고, 외부에서 받은 props를 보여주는 컵포넌트\r\n  handleIncrement = () => {\r\n    this.props.onIncrement(this.props.habit);\r\n  };\r\n  handleDecrement = () => {\r\n    this.props.onDecrement(this.props.habit);\r\n  };\r\n  handleDelete = () => {\r\n    this.props.onDelete(this.props.habit);\r\n  };\r\n\r\n  render() {\r\n    const { name, count } = this.props.habit; // 각각의 데이터 변수에 담기(동일한 이름 써야 함)\r\n\r\n    console.log(`habit: ${name}`);\r\n\r\n    return (\r\n      <li className='habit'>\r\n        <span className='habit-name'>{name}</span>\r\n        <span className='habit-count'>{count}</span>\r\n        <button\r\n          className='habit-button habit-increase'\r\n          onClick={this.handleIncrement}\r\n          // onClick={() => {\r\n          //   this.props.onIncrement(this.props.habit);\r\n          // }} handleIncremnt 없이 이렇게 익명함수로 전달 할 수도 있음\r\n        >\r\n          <i className='far fa-plus-square'></i>\r\n        </button>\r\n        <button\r\n          className='habit-button habit-decrease'\r\n          onClick={this.handleDecrement}\r\n        >\r\n          <i className='far fa-minus-square'></i>\r\n        </button>\r\n        <button\r\n          className='habit-button habit-delete'\r\n          onClick={this.handleDelete}\r\n        >\r\n          <i className='fas fa-trash'></i>\r\n        </button>\r\n      </li>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Habit;\r\n","import React, { memo } from 'react';\r\n//함수형 컴포넌트\r\n//memo :PureComponent처럼 props 변경없으면 랜더 안됨\r\nconst HabitAddForm = memo(props => {\r\n  console.log('habit Add form');\r\n  const inputRef = React.createRef(); //ref 생성\r\n  const formRef = React.createRef();\r\n\r\n  const onSubmit = event => {\r\n    event.preventDefault(); //submit발생하면 기본적으로 페이지 리프레시됨. 그래서 브라우저 기능 취소함\r\n    const name = inputRef.current.value; //ref안의 현재있는 요소의 value\r\n    name && props.onAdd(name); //name이 있으면(=비어있지않으면=true면) props.onAdd에 name전달\r\n    // this.inputRef.current.value = ''; 초기화 방법1\r\n    formRef.current.reset(); //초기화방법2\r\n  };\r\n  return (\r\n    <form ref={formRef} className='add-form' onSubmit={onSubmit}>\r\n      <input\r\n        ref={inputRef} //브라우저에 컴포넌트 표기되면 이걸통해 inputRef연결되서 input요소 읽어올 수 있음\r\n        type='text'\r\n        className='add-input'\r\n        placeholder='Please enter your habit'\r\n      />\r\n      <button className='add-btn'>add</button>\r\n    </form>\r\n  );\r\n});\r\n\r\nexport default HabitAddForm;\r\n","import React, { Component } from 'react';\r\nimport Habit from './habit';\r\nimport HabitAddForm from './habitAddForm';\r\n\r\nclass Habits extends Component {\r\n  handleAdd = name => {\r\n    this.props.onAdd(name);\r\n  };\r\n\r\n  render() {\r\n    console.log('habits');\r\n    return (\r\n      <div>\r\n        <HabitAddForm onAdd={this.handleAdd} />\r\n        <ul className='habits'>\r\n          {this.props.habits.map(habit => (\r\n            <Habit\r\n              key={habit.id}\r\n              habit={habit}\r\n              onIncrement={this.props.onIncrement}\r\n              onDecrement={this.props.onDecrement}\r\n              onDelete={this.props.onDelete}\r\n            />\r\n          ))}\r\n        </ul>\r\n        <button className='habits-reset' onClick={this.props.onReset}>\r\n          Reset\r\n        </button>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Habits;\r\n","import React, { PureComponent } from 'react';\r\n\r\nclass Header extends PureComponent {\r\n  render() {\r\n    console.log('header');\r\n\r\n    return (\r\n      <header className='header'>\r\n        <i className=' header-logo fas fa-quidditch'></i>\r\n        <span>Habit Tracker </span>\r\n        <span className='header-count'>{this.props.totalCount}</span>\r\n      </header>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Header;\r\n","import React, { Component } from 'react';\nimport './app.css';\nimport Habits from './components/habits';\nimport Header from './components/header';\n\nclass App extends Component {\n  state = {\n    habits: [\n      { id: 1, name: 'Reading', count: 0 },\n      { id: 2, name: 'Running', count: 0 },\n      { id: 3, name: 'coding', count: 0 }\n    ]\n  };\n\n  handleIncrement = habit => {\n    const habits = this.state.habits.map(item => {\n      if (item.id === habit.id) {\n        //전달받은 habit의 id (클릭한 habit의 id)와 habits 데이터의 id를 비교해서 같다면 (클릭한 habit이면)\n        return { ...habit, count: habit.count + 1 }; // 나머지 항목을 그대로 복사하면서 count는 +1한 걸 리턴\n      }\n      return item; // 클릭하지 않은 항목은 그대로 return item해서 기존의 것 리턴\n    });\n    this.setState({ habits });\n\n    ///\n    /*💩 spread syntax이용해서 복사해도 다차원객체는 주소값이 복사됨 (=원본객체에 영향줌)\n    const habits = [...this.state.habits];\n    const index = habits.indexOf(habit);\n    habits[index].count++; */\n    /* this.setState({ habits: habits});  key인 habits(왼쪽, state의 habits)에 로컬변수habit(오른쪽)배열을 넣는다\n    habits:habits 처럼 key와 value가 동일한 이름이면 하나로 생략 가능 */\n\n    /**\n     * state를 직접 수정하지 않는 이유\n     * this.state.habits[index].count <- 이런식으로 오브젝트안의 데이터를 수정하면\n     * 결국은 동일한 오브젝트이기 때문에 동일하다고 판단해서 렌더링이 일어나지 않음\n     */\n  };\n\n  handleDecrement = habit => {\n    const habits = this.state.habits.map(item => {\n      if (item.id === habit.id) {\n        const count = habit.count - 1;\n        return { ...habit, count: count < 0 ? 0 : count }; //새로운 객체를 생성해서 리턴해주므로 객체의 참조값이 변경되어 해당 객체만 렌더링\n      }\n      return item; //기존 this.state.habits 객체 그대로 리턴함(참조값 변경안되서 렌더링 안되게)\n    });\n    this.setState({ habits });\n    // const habits = [...this.state.habits];\n    // const index = habits.indexOf(habit);\n    // const count = habits[index].count - 1;\n    // habits[index].count = count < 0 ? 0 : count; //💩\n  };\n\n  handleDelete = habit => {\n    // filter을 이용해서 수정사항을 반영한 배열을 생성함\n    const habits = this.state.habits.filter(item => item.id !== habit.id);\n    this.setState({ habits });\n\n    //   다른방법: splice이용{\n    //   const habits = [...this.state.habits];\n    //   const index = habits.indexOf(habit);\n    //   habits.splice(index, 1);\n    //   this.setState({ habits });\n    //  }\n  };\n\n  handleAdd = name => {\n    const habits = [...this.state.habits, { id: Date.now(), name, count: 0 }]; //name:name <-동일한 이름은 생략가능\n    this.setState({ habits });\n  };\n\n  handleReset = () => {\n    const habits = this.state.habits.map(habit => {\n      if (habit.count !== 0) {\n        return { ...habit, count: 0 };\n      }\n      return habit;\n    });\n    this.setState({ habits });\n    // const habits = this.state.habits.map(habit => {\n    //   habit.count = 0;\n    //   return habit;\n    // });\n  };\n\n  countHabits = () => {\n    //카운트가 0개 이상인 habit만 갯수로 계산\n    return this.state.habits.filter(habit => habit.count > 0).length;\n  };\n\n  render() {\n    console.log('app');\n\n    return (\n      <div>\n        <Header totalCount={this.countHabits()} />\n        <Habits\n          habits={this.state.habits}\n          onIncrement={this.handleIncrement}\n          onDecrement={this.handleDecrement}\n          onDelete={this.handleDelete}\n          onAdd={this.handleAdd}\n          onReset={this.handleReset}\n        />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import React, { useCallback, useEffect, useState } from 'react';\r\n\r\nconst SimpleHabit = () => {\r\n  //react hook에서 state정의하는 방법(useState API이용)\r\n  const [count, setCount] = useState(0);\r\n  const spanRef = React.useRef();\r\n\r\n  const handleIncrement = useCallback(() => {\r\n    setCount(count + 1);\r\n  });\r\n\r\n  /*useEffect : 컴포넌트가 마운트 될 때와 업데이트 될 때 마다 호출됨\r\n  만약 어떤 값이 변경될때만 호출하고 싶으면 두번째인자에 지정해주면 됨.\r\n  두번째인자를 지정하지않으면 마운트될때나 업데이트될때마다 호출되고 \r\n  두번째인자에 [](빈 배열) 넣으면 마운트 되었을 때만 호출됨\r\n  */\r\n  useEffect(() => {\r\n    console.log(`mounted & updated! : ${count}`);\r\n  }, [count]); //count가 변경될때만 useEffect 호출\r\n  return (\r\n    <li className='habit'>\r\n      <span ref={spanRef} className='habit-name'>\r\n        Reading\r\n      </span>\r\n      <span className='habit-count'>{count}</span>\r\n      <button className='habit-button habit-increase' onClick={handleIncrement}>\r\n        <i className='fas fa-plus-square'></i>\r\n      </button>\r\n    </li>\r\n  );\r\n};\r\n\r\nexport default SimpleHabit;\r\n/* \r\nclass컴포넌트에서 멤버변수는 클래스가 만들어질 때 한번 만들어지고 컴포넌트 변경되도 render함수만 반복 호출되지만\r\nfunction 컴포넌트는 props이나 state가 변경되면 이 코드블럭 전체(함수전체)가 계속 반복 호출됨\r\n그래서 지역변수들도 호출될때마다 반복해서 새로 만들어짐\r\n그런데 그럴때마다 useState가 0으로 초기화되지않고 이전 값을 기억하는 이유는?\r\nuseState는 알아서 동일한 값을 메모리에 저장하고 있음 (useState를 아무리 많이 호출해도 state는 따로 저장되어져서 계속 동일한 값(이전에 저장한 값) 받아옴)\r\n*/\r\n/*\r\n함수형 컴포넌트에서 createRef를 이용하면 함수호출될때마다 새로운 ref를 만들고 할당함.\r\n그래서 리액트 훅에서 제공하는 useRef 이용\r\nuseRef : 한번만 만들고 메모리에 저장해서 재사용\r\n콜백함수도 마찬가지로 useCallback() 사용\r\n주의점 : ??  실전프젝에서 알려주실 예정\r\n */\r\n\r\n/**UseEffect\r\n * 컴포넌트가 마운트되었을 때, 업데이트 될 떄 마다 호출됨\r\n */\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './app';\nimport '@fortawesome/fontawesome-free/js/all.js';\nimport SimpleHabit from './components/simpleHabit';\n\nReactDOM.render(\n  <React.StrictMode>\n    <SimpleHabit />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}